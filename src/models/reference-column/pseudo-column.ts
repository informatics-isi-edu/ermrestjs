// models
import SourceObjectWrapper from '@isrd-isi-edu/ermrestjs/src/models/source-object-wrapper';
import SourceObjectNode from '@isrd-isi-edu/ermrestjs/src/models/source-object-node';
import { ReferenceColumn, ReferenceColumnTypes } from '@isrd-isi-edu/ermrestjs/src/models/reference-column';
import { CommentType } from '@isrd-isi-edu/ermrestjs/src/models/comment';
import { DisplayName } from '@isrd-isi-edu/ermrestjs/src/models/display-name';
import { Reference, RelatedReference, type Page, type Tuple } from '@isrd-isi-edu/ermrestjs/src/models/reference';

// services
import $log from '@isrd-isi-edu/ermrestjs/src/services/logger';
import ErrorService from '@isrd-isi-edu/ermrestjs/src/services/error';

// utils
import { renderMarkdown } from '@isrd-isi-edu/ermrestjs/src/utils/markdown-utils';
import { isDefinedAndNotNull, isObject, isObjectAndNotNull, isStringAndNotEmpty, verify } from '@isrd-isi-edu/ermrestjs/src/utils/type-utils';
import { fixedEncodeURIComponent } from '@isrd-isi-edu/ermrestjs/src/utils/value-utils';
import { processAggregateValue } from '@isrd-isi-edu/ermrestjs/src/utils/column-utils';
import {
  _pseudoColAggregateFns,
  _pseudoColEntityAggregateFns,
  _pseudoColAggregateExplicitName,
  _pseudoColAggregateNames,
  URL_PATH_LENGTH_LIMIT,
} from '@isrd-isi-edu/ermrestjs/src/utils/constants';

// legacy
import { Column, Key } from '@isrd-isi-edu/ermrestjs/js/core';
import { parse } from '@isrd-isi-edu/ermrestjs/js/parser';
import {
  _isEntryContext,
  _getFormattedKeyValues,
  _getRowTemplateVariables,
  _generateRowPresentation,
  generateKeyValueFilters,
  processMarkdownPattern,
  _processModelComment,
  _processSourceObjectComment,
} from '@isrd-isi-edu/ermrestjs/js/utils/helpers';

/**
 *  A pseudo-column without any actual source definition behind it.
 * This constructor assumes that the sourceObject has markdown_name and display.markdown_pattern.
 *
 * The name is currently generated by the visible columns logic. It will use the
 * "$<markdown_name>" pattern and if a column with this name already exists in the table,
 * it will append "-<integer>" to it.
 */
export class VirtualColumn extends ReferenceColumn {
  public isPseudo: boolean = true;

  isVirtualColumn = true;

  constructor(reference: Reference, sourceObjectWrapper: SourceObjectWrapper, name: string, mainTuple?: Tuple) {
    super(reference, [], sourceObjectWrapper, name, mainTuple);

    this.referenceColumnType = ReferenceColumnTypes.VIRTUAL;
  }
}

/**
 * If you want to create an object of this type, use the `createPseudoColumn` method.
 * This will only be used for general purpose pseudo-columns, using that method ensures That
 * we're creating the more specific object instead. Therefore only these cases should
 * be using this type of object:
 * 1. When sourceObject has aggregate
 * 2. When sourceObject has a path that is not just an outbound fk, or it doesn't define a related
 * entity (inbound or p&b association)
 *
 * @memberof ERMrest
 * @param {Reference} reference  column's reference
 * @param {Column} column      the column that this pseudo-column is representing
 * @param {SourceObjectWrapper} sourceObjectWrapper the sourceObjectWrapper object (might be undefined)
 * @param {string=} name        to avoid processing the name again, this might be undefined.
 * @param {Tuple=} mainTuple   if the reference is referring to just one tuple, this is defined.
 * @constructor
 * @class
 */
export class PseudoColumn extends ReferenceColumn {
  /**
   * indicates that this object represents a PseudoColumn.
   */
  public isPseudo: boolean = true;

  public isPathColumn: boolean = true;

  /**
   * If the pseudo-column is connected via a path to the table or not.
   */
  public hasPath: boolean;

  /**
   * If the pseudoColumn is in entity mode
   */
  public isEntityMode: boolean;

  /**
   * If the pseudoColumn is referring to a unique row (the path is one to one)
   */
  public isUnique: boolean;

  /**
   * If aggregate function is defined on the column.
   */
  public hasAggregate: boolean;

  public baseColumn: Column;

  constructor(reference: Reference, column: Column, sourceObjectWrapper: SourceObjectWrapper, name?: string, mainTuple?: Tuple) {
    super(reference, [column], sourceObjectWrapper, name, mainTuple);

    this.referenceColumnType = ReferenceColumnTypes.PSEUDO;

    this.hasPath = this.sourceObjectWrapper!.hasPath;
    this.isEntityMode = this.sourceObjectWrapper!.isEntityMode;
    this.isUnique = this.sourceObjectWrapper!.isUnique;
    this.hasAggregate = this.sourceObjectWrapper!.hasAggregate;

    this.baseColumn = column;
    this._currentTable = reference.table;
    this.table = column.table;
  }

  /**
   * Format the presentation value corresponding to this pseudo-column definition.
   * 1. If source is not in entity mode: use the column's heuristic
   * 2. Otherwise if it's not a path, apply the same logic as KeyPseudoColumn presentation based on the key.
   * 2. Otherwise if path is one to one (all outbound), use the same logic as ForeignKeyPseudoColumn based on last fk.
   * 3. Otherwise return null value.
   *
   * @param {Object} data the raw data of the table
   * @param {String=} context the app context (optional)
   * @param {Object=} templateVariables the template variables that should be used (optional)
   * @param {Object=} options (optional)
   * @returns {Object} A key value pair containing value and isHTML that detemrines the presentation.
   */
  formatPresentation(data: any = {}, context?: string, templateVariables?: any, options: any = {}): any {
    if (!isStringAndNotEmpty(context)) {
      context = this._context;
    }

    const nullValue = {
      isHTML: false,
      value: this._getNullValue(context!),
      unformatted: this._getNullValue(context!),
    };

    if (_isEntryContext(context)) {
      return nullValue;
    }

    if (this.hasWaitFor && !options.skipWaitFor) {
      return nullValue;
    }

    // has aggregate, we should get the value by calling aggregate function
    if (this.hasAggregate) {
      return nullValue;
    }

    // not representing a row
    if (!this.isUnique) {
      return nullValue;
    }

    // make sure templateVariables is valid
    if (!isObjectAndNotNull(templateVariables)) {
      templateVariables = _getFormattedKeyValues(this.table, context!, data);
    }

    // not in entity mode, just return the column value.
    if (!this.isEntityMode) {
      // we should not pass the same templateVariables to the parent,
      // since when it goes to the parent it will be based on the leaf table
      // while the templateVariables is based on the parent table.
      // only if we're going to use this with sourceMarkdownPattern we should pass this value
      return super.formatPresentation(data, context, this.display.sourceMarkdownPattern ? templateVariables : null);
    }

    if (this.display.sourceMarkdownPattern) {
      const keyValues: any = {};
      const selfTemplateVariables = {
        $self: _getRowTemplateVariables(this.table, context!, data),
      };
      Object.assign(keyValues, templateVariables, selfTemplateVariables);
      return processMarkdownPattern(this.display.sourceMarkdownPattern, keyValues, this.table, context!, {
        templateEngine: this.display.sourceTemplateEngine,
      });
    }

    // in entity mode, return the foreignkey value
    const pres = _generateRowPresentation(this.lastForeignKeyNode!.nodeObject.key, data, context!, this._getShowForeignKeyLink(context!));
    return pres ? pres : nullValue;
  }

  sourceFormatPresentation(templateVariables: any, columnValue: any, mainTuple: Tuple) {
    const baseCol = this.baseColumn;
    const context = this._context;
    let selfTemplateVariables: any = {};

    if (this.display.sourceMarkdownPattern) {
      // for aggregate, the columnValue has the value precomputed
      if (this.hasAggregate && columnValue) {
        selfTemplateVariables = columnValue.templateVariables;
      }
      // all-outbound paths
      else if (this.hasPath && this.isUnique) {
        // use the linked data if exists
        if (!mainTuple.linkedData[this.name]) {
          selfTemplateVariables = {};
        }
        // scalar default
        else if (!this.isEntityMode) {
          selfTemplateVariables = {
            $self: baseCol.formatvalue(mainTuple.linkedData[this.name][baseCol.name], context),
            $_self: mainTuple.linkedData[this.name][baseCol.name],
          };
        }
        // entity default
        else {
          selfTemplateVariables = {
            $self: _getRowTemplateVariables(this.table, context, mainTuple.linkedData[this.name]),
          };
        }
      }
      // any other paths
      else if (baseCol) {
        selfTemplateVariables = {
          $self: baseCol.formatvalue(mainTuple.data[baseCol.name], context),
          $_self: mainTuple.data[baseCol.name],
        };
      }

      const keyValues = {};
      Object.assign(keyValues, templateVariables, selfTemplateVariables);
      return processMarkdownPattern(this.display.sourceMarkdownPattern, keyValues, this.table, context, {
        templateEngine: this.display.sourceTemplateEngine,
      });
    }

    // aggregate
    if (this.hasAggregate) {
      const nullValue = this._getNullValue(context);
      return columnValue ? columnValue : { isHTML: false, value: nullValue, unformatted: nullValue };
    }

    // all outbound
    if (this.hasPath && this.isUnique) {
      return this.formatPresentation(mainTuple.linkedData[this.name], mainTuple.page.reference.context, null, { skipWaitFor: true });
    }

    // other cases
    return super.sourceFormatPresentation(templateVariables, columnValue, mainTuple);
  }

  /**
   * Returns a promise that gets resolved with list of aggregated values in the same
   * order of tuples of the page that is passed.
   * Each returned value has the following attributes:
   *  - value
   *  - isHTML
   *  - templateVariables: the template variables that the client uses to eventually pass to sourceFormatPresentation
   *
   * implementation Notes:
   * 1. This function will take care of url limitation. It might generate multiple
   * ermrest requests based on the url length, and will resolve the promise when
   * all the requests have been succeeded. If we cannot fit all the requests, an
   * error will be thrown.
   * 2. Only in case of entity scalar aggregate we are going to get all the row data.
   * In other cases, the returned data will only include the scalar value.
   * 3. Regarding the returned value:
   *  3.0. Null and empty string values are treated the same way as any array column.
   *  We are going to show the special value for them.
   *  3.1. If it's an array aggregate:
   *      3.1.1. array_display will dictate how we should join the values (csv, olist, ulist, raw).
   *      3.1.2. array_options will dictate the sort and length criteria.
   *      3.1.3. Based on entity/scalar mode:
   *          3.1.3.1. In scalar mode, only pre_format will be applied to each value.
   *          3.1.3.2. In entity mode, we are going to return list of row_names derived from `row_name/compact`.
   *  3.2. Otherwise we will only apply the pre_format annotation for the column.
   *
   * @param  {Page} page               the page object of main (current) refernece
   * @param {Object} contextHeaderParams the object that we want to log.
   * @return {Promise}
   */
  getAggregatedValue(page: Page, contextHeaderParams?: any): Promise<{ value: any; isHTML: boolean; templateVariables: any }[]> {
    return new Promise((resolve, reject) => {
      const values: { value: any; isHTML: boolean; templateVariables: any }[] = [];
      const mainTable = this._currentTable;
      const location = this._baseReference.location;
      const http = this._baseReference.server.http;
      const column = this.baseColumns[0];
      let pathToCol: string;

      // this will dictates whether we should show rowname or not
      const aggFn = this.sourceObject.aggregate;
      const isRow = this.isEntityMode && _pseudoColEntityAggregateFns.indexOf(aggFn) !== -1;

      // verify the input
      try {
        verify(this.hasAggregate, 'this function should only be used when `hasAggregate` is true.');
        verify(page && page.reference.table === mainTable, 'given page object must be defined and from the base table.');
      } catch (e) {
        reject(e);
        return;
      }

      // create the header
      if (!contextHeaderParams || !isObject(contextHeaderParams)) {
        contextHeaderParams = { action: 'read/aggregate' };
      }
      const config = {
        headers: this.reference._generateContextHeader(contextHeaderParams),
      };

      // return empty list if page is empty
      if (page.tuples.length === 0) {
        resolve(values);
        return;
      }

      // make sure table has shortestkey of length 1
      if (mainTable.shortestKey.length > 1) {
        $log.warn('This function only works with tables that have at least a simple key.');
        resolve(values);
        return;
      }

      const currTable = 'T';
      const baseTable = this.hasPath ? 'M' : currTable;

      const keyColName = mainTable.shortestKey[0].name;
      const keyColNameEncoded = fixedEncodeURIComponent(mainTable.shortestKey[0].name);
      const projection = `/c:=:${baseTable}:${keyColNameEncoded};v:=${aggFn}(${currTable}:${isRow ? '*' : fixedEncodeURIComponent(column.name)})`;

      // generate the base path in the following format:
      // <baseUri><basePath><filters><path-to-pseudo-col><projection>
      // the following shows where `/` is stored for each part:
      // <baseUri/><basePath/><filters></path-from-main-to-pseudo-col></projection>
      const baseUri = [location.service, 'catalog', location.catalog, 'attributegroup'].join('/') + '/';
      const basePath = baseTable + ':=' + fixedEncodeURIComponent(mainTable.schema.name) + ':' + fixedEncodeURIComponent(mainTable.name) + '/';
      pathToCol = this.sourceObjectWrapper!.toString(false, false, currTable);
      if (pathToCol.length > 0) {
        pathToCol = '/' + pathToCol;
      }

      // make sure just projection and base uri doesn't go over limit.
      if (basePath.length + pathToCol.length + projection.length >= URL_PATH_LENGTH_LIMIT) {
        $log.warn("couldn't generate the requests because of url limitation");
        resolve(values);
        return;
      }

      // get the computed filters
      const keyValueRes = generateKeyValueFilters(
        mainTable.shortestKey,
        page.tuples.map((t) => t.data),
        mainTable.schema.catalog,
        (basePath + pathToCol + projection).length,
        mainTable.displayname.value,
      );

      if (!keyValueRes.successful || !keyValueRes.filters) {
        $log.warn(keyValueRes.message);
        resolve(values);
        return;
      }

      // turn the paths into requests
      const httpPromises = keyValueRes.filters.map((f) => {
        return http.get(baseUri + basePath + f.path + pathToCol + projection, config);
      });

      // if adding any of the filters would go over url limit
      if (httpPromises.length === 0) {
        $log.warn("couldn't generate the requests because of url limitation");
        resolve(values);
        return;
      }

      Promise.all(httpPromises)
        .then((response) => {
          const result: any[] = [];
          let responseValues: any[] = [];
          let value: any;

          response.forEach((r: any) => {
            responseValues = responseValues.concat(r.data);
          });

          // make sure we're returning the result in the same order as input
          page.tuples.forEach((t) => {
            // find the corresponding value in result
            value = responseValues.find((v) => {
              return v.c === t.data[keyColName];
            });

            result.push(processAggregateValue(value && value.v ? value.v : null, this, aggFn, isRow));
          });

          resolve(result);
        })
        .catch((err) => {
          reject(ErrorService.responseToError(err));
        });
    });
  }

  protected _determineSortable(): void {
    this._sortColumns_cached = [];
    this._sortable = false;

    // disable sort if it has aggregate
    if (this.hasAggregate) {
      return;
    }

    if (this.isUnique) {
      if (this.isEntityMode) {
        const fk = this.lastForeignKeyNode!.nodeObject;
        const display = fk.getDisplay(this._context);

        // disable the sort
        if (display !== undefined && display.columnOrder === false) return;

        // use the column_order
        if (display !== undefined && display.columnOrder !== undefined && display.columnOrder.length !== 0) {
          this._sortColumns_cached = display.columnOrder;
          this._sortable = true;
          return;
        }

        if (this.reference.display._rowOrder !== undefined) {
          this._sortColumns_cached = this.reference.display._rowOrder;
          this._sortable = true;
          return;
        }
      }

      // use the column's
      this._sortColumns_cached = this.baseColumns[0]._getSortColumns(this._context); //might return undefined

      if (typeof this._sortColumns_cached === 'undefined') {
        this._sortColumns_cached = [];
      } else {
        this._sortable = true;
      }
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  protected _determineInputDisabled(context: string): boolean | { message: string } {
    throw new Error('can not use this type of column in entry mode.');
  }

  /**
   * If the first foreign key is outbound, this function will return the value that this pseudo-column represents.
   *
   * The first fk must be outbound because the path is generated from the table that the first fk refers to. This is
   * useful for fetching the values of wait-fors in the entry contexts. Since the main record might not be available yet,
   * we're starting from the fk table.
   *
   * Ideally this and getAggregatedValue should be merged, these are the differences:
   * - for this function agg fn is not required.
   * - this function requires the first fk to be outbound, while getAggregatedValue doesn't.
   * - the generated path here ignores the first hop.
   * - if the key value for any of the rows is null, this will only ignore that row (getAggregatedValue will just give up and return empty).
   *
   * @param {any} data the submission data
   * @param {Record<string, any>} contextHeaderParams
   */
  getFirstOutboundValue(data: any[], contextHeaderParams?: Record<string, any>): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const encode = fixedEncodeURIComponent;
      const location = this._baseReference.location;
      const http = this._baseReference.server.http;

      // these are the same checks as the processWaitFor in the entry context. since that's the only usecase of this for now.
      const sw = this.sourceObjectWrapper!;
      const firstFk = this.firstForeignKeyNode ? this.firstForeignKeyNode.nodeObject : null;
      if (firstFk === undefined || this.firstForeignKeyNode!.isInbound) {
        $log.warn('This function should only be used when the first foreign key is outbound.');
        resolve([]);
        return;
      }
      if (sw.foreignKeyPathLength < 2 || sw.hasPrefix || (sw.isFiltered && sw.filterProps && sw.filterProps.hasRootFilter)) {
        $log.warn('This function only support paths that start with outbound, have no filter or prefix, and at least 2 fk hops.');
        resolve([]);
        return;
      }

      // create the header
      if (!contextHeaderParams || !isObject(contextHeaderParams)) {
        contextHeaderParams = { action: 'read/outbound' };
      }
      const config = {
        headers: this.reference._generateContextHeader(contextHeaderParams),
      };
      // if agg is missing, we're getting the rows
      const aggFn = this.sourceObject.aggregate ? this.sourceObject.aggregate : 'array_d';
      const isRow = this.isEntityMode && _pseudoColEntityAggregateFns.indexOf(aggFn) !== -1;
      const isAllOutbound = this.isPathColumn && this.hasPath && this.isUnique && !this.hasAggregate;

      // the table that the path starts with
      const baseTable = firstFk.key.table;
      const baseTableKeyColumns = firstFk.key.colset.columns;

      const currTableAlias = 'T';
      const baseTableAlias = 'M';
      let aliasUsedForProjectedValue = 'v';
      let num = 1;
      while (baseTableKeyColumns.some((c: any) => c.name === aliasUsedForProjectedValue)) {
        aliasUsedForProjectedValue = 'v' + num++;
      }

      const column = this.baseColumns[0];
      let projection =
        '/' +
        baseTableKeyColumns
          .map((c: any) => {
            return `${baseTableAlias}:${encode(c.name)}`;
          })
          .join(',');
      projection += `;${aliasUsedForProjectedValue}:=${aggFn}(${currTableAlias}:${isRow ? '*' : encode(column.name)})`;

      const lastFk = this.lastForeignKeyNode;
      const baseUri = `${location.service}/catalog/${location.catalog}/attributegroup/`;
      const basePath = `${baseTableAlias}:=${encode(baseTable.schema.name)}:${encode(baseTable.name)}/`;

      // NOTE we're not allowing first hop filter or path filter for this case, so the following is assuming that
      const pathToCol = this.sourceObjectWrapper!.sourceObjectNodes!.reduce((acc: string, sn: SourceObjectNode, index: number) => {
        // ignoring the first hop
        if (index === 0) return '/';
        // add alias to the last hop
        const addAlias = sn === lastFk;
        return acc + (index > 1 ? '/' : '') + (addAlias ? `${currTableAlias}:=` : '') + sn.toString();
      }, '');

      // make sure just projection and base uri doesn't go over limit.
      if ((basePath + pathToCol + projection).length >= URL_PATH_LENGTH_LIMIT) {
        $log.warn("couldn't generate the requests because of url limitation");
        resolve([]);
        return;
      }

      // get the computed filters
      const keyData: any[] = [];
      for (let rowIndex = 0; rowIndex < data.length; rowIndex++) {
        const temp: any = {};
        let hasNull = false;
        for (let colIndex = 0; colIndex < firstFk.colset.columns.length; colIndex++) {
          const c = firstFk.colset.columns[colIndex];
          if (isDefinedAndNotNull(data[rowIndex][c.name])) {
            temp[firstFk.mapping.get(c).name] = data[rowIndex][c.name];
          } else {
            hasNull = true;
            break;
          }
        }
        // ignore the row if any of the key values is null
        if (!hasNull) {
          keyData.push(temp);
        }
      }
      const keyValueRes = generateKeyValueFilters(
        baseTableKeyColumns,
        keyData,
        baseTable.schema.catalog,
        (basePath + pathToCol + projection).length,
        baseTable.displayname.value,
      );

      if (!keyValueRes.successful || !keyValueRes.filters) {
        $log.warn(keyValueRes.message);
        resolve([]);
        return;
      }

      // turn the paths into request
      const promises = keyValueRes.filters.map((f: any) => {
        return http.get(baseUri + basePath + f.path + pathToCol + projection, config);
      });

      // if adding any of the filters would go over url limit
      if (promises.length === 0) {
        $log.warn("couldn't generate the requests because of url limitation");
        resolve([]);
        return;
      }

      Promise.all(promises)
        .then((response) => {
          const result: any[] = [];
          let values: any[] = [];
          response.forEach((r: any) => {
            values = values.concat(r.data);
          });

          data.forEach((d) => {
            // find the value corresponding to the current tuple
            const value = values.find((v) => {
              return baseTableKeyColumns.every((c: any) => {
                return v[c.name] === d[firstFk.mapping.getFromColumn(c).name];
              });
            });

            const presValue = processAggregateValue(value ? value[aliasUsedForProjectedValue] : null, this, aggFn, isRow);
            // if it's alloutbound and agg fn was missing, we added array_d so we can send the request,
            // so make sure the returned value is not actually array
            if (isAllOutbound && !this.sourceObject.aggregate) {
              if ('$self' in presValue.templateVariables && Array.isArray(presValue.templateVariables.$self)) {
                presValue.templateVariables.$self = presValue.templateVariables.$self[0];
              }
              if ('$_self' in presValue.templateVariables && Array.isArray(presValue.templateVariables.$_self)) {
                presValue.templateVariables.$_self = presValue.templateVariables.$_self[0];
              }
            }

            result.push(presValue);
          });

          resolve(result);
        })
        .catch((err) => {
          reject(ErrorService.responseToError(err));
        });
    });
  }

  // Private cached properties for getters
  private _key?: any;
  private _aggregateFn?: string | null;
  private _reference?: Reference;
  private _canUseScalarProjection?: boolean;

  /**
   * The tooltip that should be used for this column.
   * It will return the first applicable rule:
   * 1. comment that is defined on the sourceObject, use it.
   * 2. if aggregate and scalar use the "<function> <col_displayname>"
   * 3. if aggregate and entity use the "<function> <table_displayname>"
   * 3. In entity mode, return the table's displayname.
   * 4. In scalar return the column's displayname.
   */
  get comment(): CommentType {
    if (this._comment === undefined) {
      const getComment = (self: PseudoColumn): any => {
        if (self.hasAggregate) {
          // if defined on the sourceObject use it.
          const com = _processSourceObjectComment(self.sourceObject);
          if (com) {
            return com;
          }

          // otherwise generate one
          const agIndex = _pseudoColAggregateFns.indexOf(self.sourceObject.aggregate);
          let dname = self.baseColumns[0].displayname.unformatted;
          if (self.isEntityMode) {
            dname = self.baseColumns[0].table.displayname.unformatted;
          }

          return _processModelComment([_pseudoColAggregateExplicitName[agIndex], dname].join(' '), false);
        }

        // if it's not aggregate, we can get it from the table or column depending on entity mode:
        let disp: any, commentDisplayMode: any;
        if (!self.isEntityMode) {
          disp = self.baseColumns[0].getDisplay(self._context);
          commentDisplayMode = disp.commentDisplayMode;
        } else {
          disp = self.table.getDisplay(self._context);
          commentDisplayMode = disp.tableCommentDisplayMode;
        }

        return _processSourceObjectComment(
          self.sourceObject,
          disp.comment ? disp.comment.unformatted : null,
          disp.commentRenderMarkdown,
          commentDisplayMode,
        );
      };

      this._comment = getComment(this);
    }
    return this._comment!;
  }

  /**
   * The tooltip that should be used for this column.
   * It will return the first applicable rule:
   * 1. comment that is defined on the sourceObject, use it.
   * 2. if aggregate and scalar use the "<function> <col_displayname>"
   * 3. if aggregate and entity use the "<function> <table_displayname>"
   * 3. In entity mode, return the table's displayname.
   * 4. In scalar return the column's displayname.
   */
  get displayname(): DisplayName {
    if (this._displayname === undefined) {
      const attachDisplayname = (self: PseudoColumn): void => {
        if (self.sourceObject.markdown_name) {
          self._displayname = {
            value: renderMarkdown(self.sourceObject.markdown_name, true),
            unformatted: self.sourceObject.markdown_name,
            isHTML: true,
          };
          return;
        }

        if (self.hasAggregate) {
          // actual displayname
          void super.displayname; // this will set the _displayname if it wasn't set before
          const displayname = self.isEntityMode ? self.baseColumns[0].table.displayname : self._displayname!;

          // prefix
          const agIndex = _pseudoColAggregateFns.indexOf(self.sourceObject.aggregate);
          const name = _pseudoColAggregateNames[agIndex];

          self._displayname = {
            value: name ? [name, displayname.value].join(' ') : displayname.value,
            unformatted: name ? [name, displayname.unformatted].join(' ') : displayname.unformatted,
            isHTML: displayname.isHTML,
          };
          return;
        }

        if (!self.isEntityMode) {
          Object.getOwnPropertyDescriptor(ReferenceColumn.prototype, 'displayname')!.get!.call(self);
          return;
        }

        // displayname of the table.
        self._displayname = self.baseColumns[0].table.displayname;
        return;
      };

      attachDisplayname(this);
    }
    return this._displayname!;
  }

  /**
   * If the pseudoColumn is in entity mode will return the key that this column represents
   */
  get key(): Key | null {
    if (this._key === undefined) {
      this._key = this.isEntityMode ? this.baseColumn.uniqueNotNullKey : null;
    }
    return this._key;
  }

  get aggregateFn(): string | null {
    if (this._aggregateFn === undefined) {
      this._aggregateFn = this.hasAggregate ? this.sourceObject.aggregate : null;
    }
    return this._aggregateFn!;
  }

  /**
   * Returns a reference to the current pseudo-column
   * This is how it behaves:
   * 1. If pseudo-column has no path, it will return the base reference.
   * 3. if mainTuple is available, create the reference based on this path:
   *      <pseudoColumnSchema:PseudoColumnTable>/<path from pseudo-column to main table>/<facets based on value of shortestkey of main table>
   * 4. Otherwise create the path by traversing the path
   */
  get reference(): Reference | RelatedReference {
    if (this._reference === undefined) {
      if (!this.hasPath) {
        this._reference = this._baseReference.copy(undefined, undefined, this);
      } else {
        let facet: unknown;
        if (this._mainTuple) {
          facet = this.sourceObjectWrapper!.getReverseAsFacet(this._mainTuple, this._baseReference.table);
        }

        // if data didn't exist, we should traverse the path
        let uri = this.table.uri;
        if (!isObjectAndNotNull(facet)) {
          uri = this._baseReference.location.compactUri + '/' + this.sourceObjectWrapper!.toString(false, false);
        }

        // this._reference = new Reference(parse(uri), this.table.schema.catalog, this.displayname, this.comment, this);
        this._reference = new RelatedReference(
          parse(uri),
          this.table.schema.catalog,
          this._baseReference.table,
          this.firstForeignKeyNode!.nodeObject,
          [],
          [],
          this.compressedDataSource,
          undefined,
          this.displayname,
          this.comment,
          this,
        );

        // make sure data exists
        if (isObjectAndNotNull(facet)) {
          this._reference.location.facets = facet;
        }
      }
    }
    return this._reference;
  }

  set reference(ref: Reference) {
    //TODO this should be revisited, chaise is mutating the reference!
    this._reference = ref;
  }
  get default(): unknown {
    throw new Error('can not use this type of column in entry mode.');
  }

  get nullok(): boolean {
    throw new Error('can not use this type of column in entry mode.');
  }

  /**
   * Whether we can use the raw column in the projection list or not.
   *
   * If we only need the value of scalar column and none of the other columns of the
   * all-outbound path then we can simply use the scalar projection.
   * Therefore the pseudo-column must:
   * - be all-outbound path in scalar mode
   * - the leaf column cannot have any column_display annotation
   * - the leaf column cannot be sorted or doesn't have a sort based on other columns of the table.
   */
  get canUseScalarProjection(): boolean {
    if (this._canUseScalarProjection === undefined) {
      const populate = (self: PseudoColumn): boolean => {
        // only in scalar mode
        if (self.isEntityMode || !self.isUnique) {
          return false;
        }
        // if it has column_display we cannot use scalar
        if (self.baseColumn.getDisplay(self._context).isMarkdownPattern) {
          return false;
        }
        // if it's sortable and based on other columns, we cannot use scalar
        const sortCols = (self as any)._sortColumns;
        if (self.sortable && (sortCols.length !== 1 || sortCols[0].column.name !== self.baseColumn.name)) {
          return false;
        }

        return true;
      };
      this._canUseScalarProjection = populate(this);
    }
    return this._canUseScalarProjection;
  }
}
